function [NextObs,Reward,IsDone,UpdatedInfo] = APV_stepFcn(Action,Info) 
%% StepFcn
% Input 1: Action (Current action from the agent, which must match the dimensions and data type specified in actionInfo).
% Input 2: Info (Any data that you want to pass from one step to the next. This can be the environment state or a 
%                structure containing state and parameters. The simulation or training functions (train or sim) 
%                handle this variable by:
%                1- Initializing Info using the second output argument returned by ResetFcn, at the beginning of the 
%                   episode.
%                2- Passing Info as second input argument to StepFcn at each training or simulation step.
%                3- Updating Info using the fourth output argument returned by StepFcn, UpdatedInfo).
% Output 1: Next Observation (This is the observation generated by the transition, caused by Action, from the current 
%                             state to the next one. The returned value must match the dimensions and data types 
%                             specified in observationInfo).
% Output 2: Reward (Reward generated by the transition, caused by Action, from the current state to the next one. 
%                   The returned value must be a scalar).
% Output 3: Isdone? (Logical value indicating whether to end the simulation or training episode).
% Output 4: UpdatedInfo
global XML_FOLDER; % Uppaal xml file desired location
global VTA_FOLDER; % Verifyta location on your device
global XMLFILENAME; % Name of the file with the full path
%% Take the Action and apply it to the settings
for p = 1:length(Info.CB_settings.CB)
    Info.CB_settings.CB{1, p}.t2 = Action{1,p};
end
%% Run the verification and get the results
WrongAgents = true;
% WrongAgent_pairs_IDs = []; % circuit breaker pairs with problems col1 is the first CB and col2 is the second CB
% xmlFilename = strcat(XML_FOLDER,filesep,'Uppaal_code_generation.xml');
fileID = fopen(XMLFILENAME,'w');
% fileID = fopen('../output/Uppaal_code_generation.xml','w');
GenPreamble(fileID);
if isempty(Info.F_branch) || isempty(Info.F_bus)
    fprintf("Minimum number of faults not selected \n Please select at least 1 line fault and 1 bus fault \n")
else
    fprintf(fileID,"<nta>\n");
    % Generate the global declaration where the functions Isc, Update and Clear are defined
    [LinesCBs,F_branch] = GenDeclaration1(Info.A,Info.Line,Info.Bus,Info.F_branch,Info.F_bus,Info.Irc,Info.C,Info.Iioc_values,Info.Ith_values,Info.Isc_values_Lines,Info.Isc_values_Buses,fileID,Info.Bus_connections,Info.CB_settings);
    Info.F_branch = F_branch;
    % Generate all timed automata (FG and CBs)
    GenTemplate(fileID,Info.Line,Info.Bus,Info.F_branch,Info.F_bus,Info.Irc,Info.CB_settings);
    % Generate something related to Uppaal where each timed automata is given a short name to help later when using the queries
    GenTemplateInstantiations(fileID,Info.CB_settings);
    % Generate all necessary queries needed to check for selectivty
    GenQueries1(fileID,Info.Line,Info.Bus,Info.F_branch,Info.F_bus,Info.CB_settings,LinesCBs,Info.Bus_connections);
    fprintf(fileID,"</nta>\n");
    fclose(fileID);
    % Run the verification
    cmdVerifyTA = strcat(VTA_FOLDER," -t0 ",XML_FOLDER,filesep,"Uppaal_code_generation.xml > output.log 2> trace.txt");
    % XML_FOLDER = '/Users/ahmed/Desktop/Work/PhD/Github/ABB-protections/output';
    % cmdVerifyTA = strcat(filesep,'Applications',filesep,'UPPAAL-5.1.0-beta5.app',filesep,'Contents',filesep,'Resources',filesep,'uppaal',filesep,'bin',filesep,'verifyta'," -t0 ",...
    %     XML_FOLDER,filesep,"Uppaal_code_generation.xml > output.log 2> trace.txt");
    Counter = 0;
    while WrongAgents == true %&& Counter < 5000
        system(cmdVerifyTA);
        uppaal_code = importdata(XMLFILENAME); % Import the Uppaal model as a string array
        %% Get the results (here is where we build the WrongAgent_pairs_IDs vector
        outputLogCell = importdata('output.log','\n');
        % if isstruct(outputLogCell)
        %     outputLogCell1 = outputLogCell.textdata;
        %     outputLog = strjoin(outputLogCell1);
        % else
        %     outputLog = strjoin(outputLogCell);
        % end
        outputLog = strjoin(outputLogCell);
        
        selectivityIdx = regexp(outputLog,'Formula is satisfied','once'); % if the expression appears once then there is a misconfiguration
        if isempty(selectivityIdx)
            WrongAgents = false;
            % if Counter == 1
            %     SelecIdx = 1;
            % end
            Counter = Counter + 1;
        else
            WrongCB_Expressions = regexp(outputLog,'CB[\d*]+.Closed->CB[\d*]+.Standby','match');
            WrongCB_ID_Exp = regexp(WrongCB_Expressions,'[1234567890]+','match');
            AllStandByCBs = [];
            for i = 1:length(WrongCB_ID_Exp)
                AllStandByCBs = [AllStandByCBs,',',WrongCB_ID_Exp{1,i}{1,1}];
            end
            AllStandByCBs = str2num(AllStandByCBs);
            WrongAgent_pairs = nchoosek(AllStandByCBs, 2);
            %WrongAgent_pairs_IDs = [WrongAgent_pairs_IDs;WrongAgent_pairs];
            for ii = 1:length(AllStandByCBs)
                CB_setts_idx = find(Info.CB_setts(:,1)==AllStandByCBs(ii));
                Info.CB_setts(CB_setts_idx,3) = 0; % set the CB to misconfigured option
            end
            %% Remove the query from the file to run it again
            % Find the location of the fault and remove its query
            LineFaultLoc = regexp(outputLog,'F[\d*]+ := true','match');
            if ~isempty(LineFaultLoc)
                LineFaultLocID = regexp(LineFaultLoc,'[1234567890]+','match');
                FaultedLineID = str2double(LineFaultLocID{1,1}{1,1});
                [forCounter,~] = size(WrongAgent_pairs); 
                for i = 1:forCounter
                    faultedCB_ID = WrongAgent_pairs(i,1);
                    UpstreamCB_ID = WrongAgent_pairs(i,2);
                    remove_exp_loc = sprintf('(!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; F%i)||',faultedCB_ID,UpstreamCB_ID,FaultedLineID);
                    regexploc = regexpcell(uppaal_code,remove_exp_loc);
                    if isempty(regexploc)
                        remove_exp_loc = sprintf('(!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; F%i)||',UpstreamCB_ID,faultedCB_ID,FaultedLineID);
                        % remove_exp = sprintf('\\(!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; F%i\\)\\|\\|',UpstreamCB_ID,faultedCB_ID,FaultedLineID);
                        remove_exp = sprintf('!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; F%i',UpstreamCB_ID,faultedCB_ID,FaultedLineID);
                    else
                        % remove_exp = sprintf('\\(!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; F%i\\)\\|\\|',faultedCB_ID,UpstreamCB_ID,FaultedLineID);
                        remove_exp = sprintf('!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; F%i',faultedCB_ID,UpstreamCB_ID,FaultedLineID);
                    end
                    regexploc = regexpcell(uppaal_code,remove_exp_loc); % find the location of the expression you want to remove
                    if ~isempty(regexploc)
                        dummie = regexprep(uppaal_code{regexploc,1}, remove_exp, ''); % Replace the expression with nothing
                        uppaal_code{regexploc,1} = dummie; % Add the new expression to the string ar
                        dummie2 = regexprep(uppaal_code{regexploc,1}, '\(\)\|\|', ''); % Replace the expression with nothing
                        uppaal_code{regexploc,1} = dummie2; % Add the new expression to the string array
                        dummie3 = regexprep(uppaal_code{regexploc,1}, '\(\)', ''); % Replace the expression with nothing
                        IslastOR = regexp(uppaal_code{regexploc,1},'\|\|\)');
                        if ~isempty(IslastOR)
                            All_Ors = regexp(uppaal_code{regexploc,1},'\|\|');
                            LastOccurence = length(All_Ors);
                            dummie2 = regexprep(uppaal_code{regexploc,1}, '\|\|', '',LastOccurence); % Replace the expression with nothing
                            uppaal_code{regexploc,1} = dummie2; % Add the new expression to the string array
                        end
                        % dummie2 = regexprep(uppaal_code{regexploc,1}, '\(\)\|\|', ''); % Replace the expression with nothing
                        % uppaal_code{regexploc,1} = dummie2; % Add the new expression to the string array
                    end
                    regexploc = regexpcell(uppaal_code,'formula>E&lt');
                    dummie = regexprep(uppaal_code{regexploc,1}, '\|\|\(\)', ''); % Replace the expression with nothing
                    uppaal_code{regexploc,1} = dummie; % Add the new expression to the string array
                end
            else
                BusFaultLoc = regexp(outputLog,'FB[\d*]+ := true','match');
                BusFaultLocID = regexp(BusFaultLoc,'[1234567890]+','match');
                FaultedBusID = str2double(BusFaultLocID{1,1}{1,1});
                [forCounter,~] = size(WrongAgent_pairs);
                for i = 1:forCounter
                    faultedCB_ID = WrongAgent_pairs(i,1);
                    UpstreamCB_ID = WrongAgent_pairs(i,2);
                    remove_exp_loc = sprintf('(!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; FB%i)||',faultedCB_ID,UpstreamCB_ID,FaultedBusID);
                    regexploc = regexpcell(uppaal_code,remove_exp_loc);
                    if isempty(regexploc)
                        remove_exp_loc = sprintf('(!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; FB%i)||',UpstreamCB_ID,faultedCB_ID,FaultedBusID);
                        % remove_exp = sprintf('\\(!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; FB%i\\)\\|\\|',UpstreamCB_ID,faultedCB_ID,FaultedBusID);
                        remove_exp = sprintf('!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; FB%i',UpstreamCB_ID,faultedCB_ID,FaultedBusID);
                    else
                        % remove_exp = sprintf('\\(!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; FB%i\\)\\|\\|',faultedCB_ID,UpstreamCB_ID,FaultedBusID);
                        remove_exp = sprintf('!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; FB%i',faultedCB_ID,UpstreamCB_ID,FaultedBusID);
                    end
                    regexploc = regexpcell(uppaal_code,remove_exp_loc); % find the location of the expression you want to remove
                    if ~isempty(regexploc)
                        dummie = regexprep(uppaal_code{regexploc,1}, remove_exp, ''); % Replace the expression with nothing
                        uppaal_code{regexploc,1} = dummie; % Add the new expression to the string array
                        dummie2 = regexprep(uppaal_code{regexploc,1}, '\(\)\|\|', ''); % Replace the expression with nothing
                        uppaal_code{regexploc,1} = dummie2; % Add the new expression to the string array
                        dummie3 = regexprep(uppaal_code{regexploc,1}, '\(\)', ''); % Replace the expression with nothing
                        IslastOR = regexp(uppaal_code{regexploc,1},'\|\|\)');
                        if ~isempty(IslastOR)
                            All_Ors = regexp(uppaal_code{regexploc,1},'\|\|');
                            LastOccurence = length(All_Ors);
                            dummie3 = regexprep(uppaal_code{regexploc,1}, '\|\|', '',LastOccurence); % Replace the expression with nothing
                            uppaal_code{regexploc,1} = dummie3; % Add the new expression to the string array
                        end
                        % dummie2 = regexprep(uppaal_code{regexploc,1}, '\(\)\|\|', ''); % Replace the expression with nothing
                        % uppaal_code{regexploc,1} = dummie2; % Add the new expression to the string array
                        % dummie3 = regexprep(uppaal_code{regexploc,1}, '\(\)', ''); % Replace the expression with nothing
                        % uppaal_code{regexploc,1} = dummie3; % Add the new expression to the string array
                    end
                    regexploc = regexpcell(uppaal_code,'formula>E&lt');
                    dummie = regexprep(uppaal_code{regexploc,1}, '\|\|\(\)', ''); % Replace the expression with nothing
                    uppaal_code{regexploc,1} = dummie; % Add the new expression to the string array
                end
            end
            writecell(uppaal_code,XMLFILENAME,FileType='text',QuoteStrings='none'); % write the array back to the same file
            Counter = Counter + 1;
        end
    end
end

%% Output 3: Set the Isdone output
if Counter == 1
    IsDone = true;
    SelecIdx = 1;
else
    IsDone = false;
    SelecIdx = 0;
end
%% Output 1: Set the next observation output
NumAgents = length(Info.CB_settings.CB);
NextObs = cell(1,NumAgents);
    for k = 1:NumAgents
        % NextObs{1,k} = {Info.CB_setts(k,:),SelectIdx};
        % NextObs{1,k} = Info.CB_setts(k,:);
        NextObs{1,k} = {Info.CB_setts(k,:),Info.A};
    end
%NextObs = Info.CB_setts;

%% Output 2: The Reward function
NumWrongAgents = nnz(Info.CB_setts(:,3)==0);
Reward = zeros(NumAgents,1);
for kk = 1:NumAgents
    Reward(kk,1) = (-1*NumWrongAgents) + ((NumAgents/2)*Info.CB_setts(kk,3)) + 1000*(SelecIdx); 
end

%% Output 4: Set the Updated Info Output
UpdatedInfo = Info;

end