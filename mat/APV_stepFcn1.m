function [NextObs,Reward,IsDone,UpdatedInfo] = APV_stepFcn1(Action,Info)
%% StepFcn
% Input 1: Action (Current action from the agent, which must match the dimensions and data type specified in actionInfo).
% Input 2: Info (Any data that you want to pass from one step to the next. This can be the environment state or a
%                structure containing state and parameters. The simulation or training functions (train or sim)
%                handle this variable by:
%                1- Initializing Info using the second output argument returned by ResetFcn, at the beginning of the
%                   episode.
%                2- Passing Info as second input argument to StepFcn at each training or simulation step.
%                3- Updating Info using the fourth output argument returned by StepFcn, UpdatedInfo).
% Output 1: Next Observation (This is the observation generated by the transition, caused by Action, from the current
%                             state to the next one. The returned value must match the dimensions and data types
%                             specified in observationInfo).
% Output 2: Reward (Reward generated by the transition, caused by Action, from the current state to the next one.
%                   The returned value must be a scalar).
% Output 3: Isdone? (Logical value indicating whether to end the simulation or training episode).
% Output 4: UpdatedInfo
global XML_FOLDER; % Uppaal xml file desired location
global VTA_FOLDER; % Verifyta location on your device
global XMLFILENAME; % Name of the file with the full path
%% Take the Action and apply it to the settings
for p = 1:length(Info.CB_settings.CB)
    Info.CB_settings.CB{1, p}.t2 = Action{1,p};
    Info.CB_setts(p,3) = 1; % reset the CB to correctly configured option
end
%% Run the verification and get the results
WrongAgents = true;
% Replace the t2 settings in the file with the actions
uppaal_code = importdata(XMLFILENAME); % Import the Uppaal model as a string array
querycell = regexpcell(uppaal_code,'formula>E&lt'); % the cell number in the uppaal code where the query for selectivity is written
uppaal_code{querycell,1} = Info.allqueries; % add all queries back to be checked.

t2cellLoc = regexpcell(uppaal_code,"int t2");
for kk = 1:length(t2cellLoc)
    uppaal_code{t2cellLoc(kk),1} = sprintf('  int t2 = %i;',Action{1,kk});
end
writecell(uppaal_code,XMLFILENAME,FileType='text',QuoteStrings='none'); % write the array back to the same file

% Run the verification
cmdVerifyTA = strcat(VTA_FOLDER," -t0 ",XML_FOLDER,filesep,"Uppaal_code_generation.xml > output.log 2> trace.txt");

% Counter = 0;
%% This while loop runs and checks for the wrong queries, remove the query and checks again
while WrongAgents == true
    querycheck = regexp(uppaal_code{querycell,1},'CB', 'once'); % if there is a CB in the query it means it is not an empty query
    if isempty(querycheck)
        WrongAgents = false;
        for p = 1:length(Info.CB_settings.CB)
            Info.CB_setts(p,3) = 0; % all CBs are wrong
        end
        % Counter = 2;
    else
        [status, ~] = system(cmdVerifyTA); % RUN the verification
        if status ~= 0
            disp(status);
        end
        % uppaal_code = importdata(XMLFILENAME); % Import the Uppaal model as a string array
        %% Get the results (here is where we build the WrongAgent_pairs_IDs vector
        outputLogCell = importdata('output.log','\n'); % Import the verification results
        outputLog = strjoin(outputLogCell); % put them all into one string so you can use regexp on them

        selectivityIdx = regexp(outputLog,'Formula is satisfied','once'); % if the expression appears once then there is a misconfiguration
        if isempty(selectivityIdx)
            WrongAgents = false; % if the expression is empty it means that there are no more misconfigurations
        else
            WrongCB_Expressions = regexp(outputLog,'CB[\d*]+.Closed->CB[\d*]+.Standby','match'); % find the query that was wrong
            WrongCB_ID_Exp = regexp(WrongCB_Expressions,'[1234567890]+','match'); % In that query, find the ID of the circuit breaker that is wrong
            AllStandByCBs = [];
            for i = 1:length(WrongCB_ID_Exp)
                AllStandByCBs = [AllStandByCBs,',',WrongCB_ID_Exp{1,i}{1,1}]; % Put all the CB IDs in one string variable
            end
            AllStandByCBs = str2num(AllStandByCBs); % convert the string variable into a numeric one
            WrongAgent_pairs = nchoosek(AllStandByCBs, 2); % create pairs out of the CB IDs
            %WrongAgent_pairs_IDs = [WrongAgent_pairs_IDs;WrongAgent_pairs];
            for ii = 1:length(AllStandByCBs) % for all the CB that are in the query, put their correct status to zero
                CB_setts_idx = find(Info.CB_setts(:,1)==AllStandByCBs(ii));
                Info.CB_setts(CB_setts_idx,3) = 0; % set the CB to misconfigured option
            end
            %% Remove the query from the file to run it again
            % Find the location of the fault and remove its query
            LineFaultLoc = regexp(outputLog,'F[\d*]+ := true','match');
            if ~isempty(LineFaultLoc) % check if it is a fault on a line not a bus
                LineFaultLocID = regexp(LineFaultLoc,'[1234567890]+','match');
                FaultedLineID = str2double(LineFaultLocID{1,1}{1,1});
                [forCounter,~] = size(WrongAgent_pairs);
                for i = 1:forCounter
                    faultedCB_ID = WrongAgent_pairs(i,1);
                    UpstreamCB_ID = WrongAgent_pairs(i,2);
                    remove_exp_loc = sprintf('(!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; F%i)||',faultedCB_ID,UpstreamCB_ID,FaultedLineID);
                    regexploc = regexpcell(uppaal_code,remove_exp_loc);
                    if isempty(regexploc)
                        remove_exp_loc = sprintf('(!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; F%i)||',UpstreamCB_ID,faultedCB_ID,FaultedLineID);
                        % remove_exp = sprintf('\\(!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; F%i\\)\\|\\|',UpstreamCB_ID,faultedCB_ID,FaultedLineID);
                        remove_exp = sprintf('!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; F%i',UpstreamCB_ID,faultedCB_ID,FaultedLineID);
                    else
                        % remove_exp = sprintf('\\(!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; F%i\\)\\|\\|',faultedCB_ID,UpstreamCB_ID,FaultedLineID);
                        remove_exp = sprintf('!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; F%i',faultedCB_ID,UpstreamCB_ID,FaultedLineID);
                    end
                    regexploc = regexpcell(uppaal_code,remove_exp_loc); % find the location of the expression you want to remove
                    if ~isempty(regexploc)
                        dummie = regexprep(uppaal_code{regexploc,1}, remove_exp, ''); % Replace the expression with nothing
                        uppaal_code{regexploc,1} = dummie; % Add the new expression to the string ar
                        dummie2 = regexprep(uppaal_code{regexploc,1}, '\(\)\|\|', ''); % Replace the expression with nothing
                        uppaal_code{regexploc,1} = dummie2; % Add the new expression to the string array
                        dummie3 = regexprep(uppaal_code{regexploc,1}, '\(\)', ''); % Replace the expression with nothing
                        IslastOR = regexp(uppaal_code{regexploc,1},'\|\|\)');
                        if ~isempty(IslastOR)
                            All_Ors = regexp(uppaal_code{regexploc,1},'\|\|');
                            LastOccurence = length(All_Ors);
                            dummie2 = regexprep(uppaal_code{regexploc,1}, '\|\|', '',LastOccurence); % Replace the expression with nothing
                            uppaal_code{regexploc,1} = dummie2; % Add the new expression to the string array
                        end
                        % dummie2 = regexprep(uppaal_code{regexploc,1}, '\(\)\|\|', ''); % Replace the expression with nothing
                        % uppaal_code{regexploc,1} = dummie2; % Add the new expression to the string array
                    end
                    regexploc = regexpcell(uppaal_code,'formula>E&lt');
                    dummie = regexprep(uppaal_code{regexploc,1}, '\|\|\(\)', ''); % Replace the expression with nothing
                    uppaal_code{regexploc,1} = dummie; % Add the new expression to the string array
                end
            else
                BusFaultLoc = regexp(outputLog,'FB[\d*]+ := true','match');
                BusFaultLocID = regexp(BusFaultLoc,'[1234567890]+','match');
                FaultedBusID = str2double(BusFaultLocID{1,1}{1,1});
                [forCounter,~] = size(WrongAgent_pairs);
                for i = 1:forCounter
                    faultedCB_ID = WrongAgent_pairs(i,1);
                    UpstreamCB_ID = WrongAgent_pairs(i,2);
                    remove_exp_loc = sprintf('(!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; FB%i)||',faultedCB_ID,UpstreamCB_ID,FaultedBusID);
                    regexploc = regexpcell(uppaal_code,remove_exp_loc);
                    if isempty(regexploc)
                        remove_exp_loc = sprintf('(!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; FB%i)||',UpstreamCB_ID,faultedCB_ID,FaultedBusID);
                        % remove_exp = sprintf('\\(!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; FB%i\\)\\|\\|',UpstreamCB_ID,faultedCB_ID,FaultedBusID);
                        remove_exp = sprintf('!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; FB%i',UpstreamCB_ID,faultedCB_ID,FaultedBusID);
                    else
                        % remove_exp = sprintf('\\(!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; FB%i\\)\\|\\|',faultedCB_ID,UpstreamCB_ID,FaultedBusID);
                        remove_exp = sprintf('!CB%i.Open &amp;&amp; CB%i.Open &amp;&amp; FB%i',faultedCB_ID,UpstreamCB_ID,FaultedBusID);
                    end
                    regexploc = regexpcell(uppaal_code,remove_exp_loc); % find the location of the expression you want to remove
                    if ~isempty(regexploc)
                        dummie = regexprep(uppaal_code{regexploc,1}, remove_exp, ''); % Replace the expression with nothing
                        uppaal_code{regexploc,1} = dummie; % Add the new expression to the string array
                        dummie2 = regexprep(uppaal_code{regexploc,1}, '\(\)\|\|', ''); % Replace the expression with nothing
                        uppaal_code{regexploc,1} = dummie2; % Add the new expression to the string array
                        dummie3 = regexprep(uppaal_code{regexploc,1}, '\(\)', ''); % Replace the expression with nothing
                        IslastOR = regexp(uppaal_code{regexploc,1},'\|\|\)');
                        if ~isempty(IslastOR)
                            All_Ors = regexp(uppaal_code{regexploc,1},'\|\|');
                            LastOccurence = length(All_Ors);
                            dummie3 = regexprep(uppaal_code{regexploc,1}, '\|\|', '',LastOccurence); % Replace the expression with nothing
                            uppaal_code{regexploc,1} = dummie3; % Add the new expression to the string array
                        end
                        % dummie2 = regexprep(uppaal_code{regexploc,1}, '\(\)\|\|', ''); % Replace the expression with nothing
                        % uppaal_code{regexploc,1} = dummie2; % Add the new expression to the string array
                        % dummie3 = regexprep(uppaal_code{regexploc,1}, '\(\)', ''); % Replace the expression with nothing
                        % uppaal_code{regexploc,1} = dummie3; % Add the new expression to the string array
                    end
                    regexploc = regexpcell(uppaal_code,'formula>E&lt');
                    dummie = regexprep(uppaal_code{regexploc,1}, '\|\|\(\)', ''); % Replace the expression with nothing
                    uppaal_code{regexploc,1} = dummie; % Add the new expression to the string array
                end
            end
            writecell(uppaal_code,XMLFILENAME,FileType='text',QuoteStrings='none'); % write the array back to the same file
        end
        % Counter = Counter + 1;
    end
end

%% Output 3: Set the Isdone output
if ismember(0,Info.CB_setts(:,3)) % if any CB is wrong, it means that selectivity is not achieved
    IsDone = false;
    SelecIdx = 0;
else
    IsDone = true;
    SelecIdx = 1;
end
% if Counter == 1
%     IsDone = true;
%     SelecIdx = 1;
% else
%     IsDone = false;
%     SelecIdx = 0;
% end
%% Output 1: Set the next observation output
NumAgents = length(Info.CB_settings.CB);
NextObs = cell(1,NumAgents);
for k = 1:NumAgents
    % NextObs{1,k} = {Info.CB_setts(k,:),SelectIdx};
    % NextObs{1,k} = Info.CB_setts(k,:);
    NextObs{1,k} = {Info.CB_setts(k,:),Info.A};
end
%NextObs = Info.CB_setts;

%% Output 2: The Reward function
NumWrongAgents = nnz(Info.CB_setts(:,3)==0);
Reward = zeros(NumAgents,1);
for kk = 1:NumAgents
    Reward(kk,1) = (-1*NumWrongAgents) + ((NumAgents/2)*Info.CB_setts(kk,3)) + 1000*(SelecIdx);
    % Reward(kk,1) = (-1*NumWrongAgents) + ((NumAgents/2)*Info.CB_setts(kk,3));
end

%% Output 4: Set the Updated Info Output
UpdatedInfo = Info;

end